<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Love Letter Explosion</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Quicksand:wght@300;400&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Quicksand', sans-serif;
            color: white;
            user-select: none;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            z-index: 10;
        }

        .message-box {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(8px);
            padding: 20px 40px;
            border-radius: 50px;
            border: 1px solid rgba(255, 192, 203, 0.3);
            font-family: 'Playfair Display', serif;
            font-size: 1.8rem;
            color: #ffdae0;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.8s cubic-bezier(0.23, 1, 0.32, 1);
            max-width: 80%;
            box-shadow: 0 0 30px rgba(255, 105, 180, 0.2);
        }

        .message-box.show {
            opacity: 1;
            transform: translateY(0);
        }

        #footer {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            font-weight: 300;
            letter-spacing: 2px;
            color: rgba(255, 218, 224, 0.6);
            opacity: 0;
            transition: opacity 2s ease;
        }

        #intro-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            z-index: 100;
            pointer-events: none;
            transition: opacity 1s ease;
        }

        .loading-text {
            position: absolute;
            bottom: 10%;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            letter-spacing: 4px;
            color: #444;
        }
    </style>
</head>
<body>

    <div id="intro-overlay">
        <div class="loading-text">WHISPERS IN THE GALAXY...</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="message" class="message-box"></div>
    </div>

    <div id="footer">Made with all my love.</div>

    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import gsap from 'https://cdn.skypack.dev/gsap';

        let scene, camera, renderer, composer, font;
        let galaxyItems = [];
        let planets = [];
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let currentPhase = 'intro';
        let clickCount = 0;
        let isTransitioning = false;
        let centralS = null;
        let starField;

        const PALETTE = [0xffb7c5, 0xffdae0, 0xe6e6fa, 0xffffff, 0xfcb1d1];
        const ROMANTIC_MESSAGES = [
            "I love you, Samya.",
            "You are the most beautiful part of my world.",
            "Every moment with you feels like magic.",
            "You are my favorite place.",
            "You make my heart feel full.",
            "With you, everything feels right.",
            "If I had to choose again, I would still choose you."
        ];

        // Shuffle messages for unique sequence
        let messagePool = [...ROMANTIC_MESSAGES].sort(() => Math.random() - 0.5);
        let messageIdx = 0;

        async function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020208);
            scene.fog = new THREE.FogExp2(0x020208, 0.0015);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, 0.4, 0.85
            );
            bloomPass.threshold = 0.2;
            bloomPass.strength = 1.0;
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const pLight = new THREE.PointLight(0xffb7c5, 2, 800);
            pLight.position.set(0, 50, 50);
            scene.add(pLight);

            const loader = new FontLoader();
            loader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', (loadedFont) => {
                font = loadedFont;
                document.getElementById('intro-overlay').style.opacity = '0';
                createStarfield();
                createSolarSystem();
                startExperience();
            });

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousedown', onDocumentMouseDown);
            window.addEventListener('mousemove', onDocumentMouseMove);
            window.addEventListener('touchstart', (e) => onDocumentMouseDown(e.touches[0]));

            animate();
        }

        function createSolarSystem() {
            const planetColors = [0x4b0082, 0x191970, 0x483d8b, 0x2f4f4f, 0x8b008b];
            for (let i = 0; i < 6; i++) {
                const size = 5 + Math.random() * 15;
                const geometry = new THREE.SphereGeometry(size, 32, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: planetColors[i % planetColors.length],
                    emissive: planetColors[i % planetColors.length],
                    emissiveIntensity: 0.1,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const planet = new THREE.Mesh(geometry, material);
                
                const distance = 400 + Math.random() * 400;
                const angle = Math.random() * Math.PI * 2;
                planet.position.set(Math.cos(angle) * distance, (Math.random() - 0.5) * 300, Math.sin(angle) * distance);
                
                planet.userData = {
                    orbitDistance: distance,
                    orbitSpeed: 0.0001 + Math.random() * 0.0003,
                    angle: angle
                };
                
                scene.add(planet);
                planets.push(planet);
            }
        }

        function startExperience() {
            setTimeout(createInitialS, 1000);
        }

        function createInitialS() {
            const geometry = new TextGeometry('S', {
                font: font, size: 20, height: 5, curveSegments: 12, bevelEnabled: true, bevelThickness: 1, bevelSize: 1
            });
            geometry.center();
            const material = new THREE.MeshStandardMaterial({
                color: 0xffb7c5, emissive: 0xff69b4, emissiveIntensity: 0.5, metalness: 0.7, roughness: 0.2
            });
            centralS = new THREE.Mesh(geometry, material);
            centralS.position.z = -50;
            centralS.scale.set(0, 0, 0);
            scene.add(centralS);

            gsap.to(centralS.scale, { x: 1, y: 1, z: 1, duration: 2, ease: "elastic.out(1, 0.5)" });
            gsap.to(centralS.rotation, { y: Math.PI * 2, duration: 5, repeat: -1, ease: "none" });
            gsap.to(centralS.material, { emissiveIntensity: 2, duration: 1, repeat: -1, yoyo: true, ease: "sine.inOut" });

            setTimeout(explodeToGalaxy, 3000);
        }

        function explodeToGalaxy() {
            currentPhase = 'galaxy';
            const burstCount = 12;
            for (let i = 0; i < burstCount; i++) createHeartBurst(new THREE.Vector3(0, 0, 0));

            gsap.to(centralS.scale, { x: 0, y: 0, z: 0, duration: 0.8, onComplete: () => scene.remove(centralS) });
            createGalaxy();
        }

        function createGalaxy() {
            const letterGeometries = {};
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            chars.split('').forEach(char => {
                letterGeometries[char] = new TextGeometry(char, {
                    font: font, size: 2, height: 0.5, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1
                });
                letterGeometries[char].center();
            });

            const heartShape = new THREE.Shape();
            heartShape.moveTo(0, 0);
            heartShape.bezierCurveTo(0, -0.3, -0.6, -1, -1.5, -1);
            heartShape.bezierCurveTo(-3, -1, -3, 1.1, -3, 1.1);
            heartShape.bezierCurveTo(-3, 2, -1.5, 3.2, 0, 4.5);
            heartShape.bezierCurveTo(1.5, 3.2, 3, 2, 3, 1.1);
            heartShape.bezierCurveTo(3, 1.1, 3, -1, 1.5, -1);
            heartShape.bezierCurveTo(0.6, -1, 0, -0.3, 0, 0);
            const heartGeo = new THREE.ExtrudeGeometry(heartShape, { depth: 0.5, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1 });
            heartGeo.center();

            const count = 350;
            for (let i = 0; i < count; i++) {
                // Reduced heart probability from 15% to 5%
                const isHeart = Math.random() > 0.95; 
                const char = chars[Math.floor(Math.random() * chars.length)];
                const geo = isHeart ? heartGeo : letterGeometries[char];
                
                const mat = new THREE.MeshStandardMaterial({
                    color: PALETTE[Math.floor(Math.random() * PALETTE.length)],
                    emissive: 0xff69b4, emissiveIntensity: 0.2, transparent: true, opacity: 0
                });

                const mesh = new THREE.Mesh(geo, mat);
                const radius = 60 + Math.random() * 80;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                mesh.position.set(radius * Math.sin(phi) * Math.cos(theta), radius * Math.sin(phi) * Math.sin(theta), radius * Math.cos(phi));
                mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                
                mesh.userData = {
                    basePos: mesh.position.clone(),
                    orbitSpeed: 0.001 + Math.random() * 0.005,
                    floatSpeed: 0.01 + Math.random() * 0.02,
                    floatOffset: Math.random() * Math.PI * 2,
                    axis: new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize()
                };

                scene.add(mesh);
                galaxyItems.push(mesh);
                gsap.to(mat, { opacity: 1, duration: 2, delay: Math.random() * 2 });
            }
        }

        function createStarfield() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for (let i = 0; i < 2000; i++) {
                pos.push((Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            starField = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.7, transparent: true, opacity: 0.5 }));
            scene.add(starField);
        }

        function onDocumentMouseDown(event) {
            if (isTransitioning) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(galaxyItems);
            if (intersects.length > 0) handleItemClick(intersects[0].object);
        }

        function onDocumentMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function handleItemClick(obj) {
            isTransitioning = true;
            clickCount++;

            gsap.to(obj.scale, { x: 5, y: 5, z: 5, duration: 0.5, ease: "back.out(2)" });
            galaxyItems.forEach(item => { if (item !== obj) gsap.to(item.material, { opacity: 0.1, duration: 0.5 }); });

            // Reduced click burst count from 8 to 4
            for (let i = 0; i < 4; i++) createHeartBurst(obj.position);

            const msgBox = document.getElementById('message');
            // Unique message tracking
            const msg = messagePool[messageIdx % messagePool.length];
            messageIdx++;
            
            msgBox.textContent = msg;
            msgBox.classList.add('show');

            setTimeout(() => {
                msgBox.classList.remove('show');
                gsap.to(obj.scale, { x: 1, y: 1, z: 1, duration: 1 });
                galaxyItems.forEach(item => { gsap.to(item.material, { opacity: 1, duration: 1 }); });
                setTimeout(() => {
                    isTransitioning = false;
                    if (clickCount >= 7) assembleHeart();
                }, 1000);
            }, 3000);
        }

        function createHeartBurst(position) {
            const heartShape = new THREE.Shape();
            heartShape.moveTo(0, 0);
            heartShape.bezierCurveTo(0, -0.1, -0.2, -0.3, -0.5, -0.3);
            heartShape.bezierCurveTo(-1, -0.3, -1, 0.4, -1, 0.4);
            heartShape.bezierCurveTo(-1, 0.8, -0.5, 1.2, 0, 1.8);
            heartShape.bezierCurveTo(0.5, 1.2, 1, 0.8, 1, 0.4);
            heartShape.bezierCurveTo(1, 0.4, 1, -0.3, 0.5, -0.3);
            heartShape.bezierCurveTo(0.2, -0.3, 0, -0.1, 0, 0);
            const geo = new THREE.ShapeGeometry(heartShape);
            const mat = new THREE.MeshBasicMaterial({ color: 0xff69b4, transparent: true });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(position);
            mesh.scale.set(0.5, 0.5, 0.5);
            scene.add(mesh);
            const dest = { x: position.x + (Math.random() - 0.5) * 40, y: position.y + (Math.random() - 0.5) * 40, z: position.z + (Math.random() - 0.5) * 40 };
            gsap.to(mesh.position, { x: dest.x, y: dest.y, z: dest.z, duration: 1.5 });
            gsap.to(mesh.material, { opacity: 0, duration: 1.5, onComplete: () => scene.remove(mesh) });
        }

        function assembleHeart() {
            currentPhase = 'heart';
            isTransitioning = true;
            const getHeartPoint = (t) => {
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                return new THREE.Vector3(x * 2.5, y * 2.5, 0);
            };
            galaxyItems.forEach((item, i) => {
                const t = (i / galaxyItems.length) * Math.PI * 2;
                const targetPos = getHeartPoint(t);
                targetPos.z = (Math.random() - 0.5) * 5;
                gsap.to(item.position, { x: targetPos.x, y: targetPos.y, z: targetPos.z, duration: 4, ease: "power3.inOut" });
                gsap.to(item.rotation, { x: 0, y: 0, z: 0, duration: 4 });
                gsap.to(item.material, { emissiveIntensity: 1, duration: 4 });
            });
            gsap.to(camera.position, { z: 120, y: 10, duration: 5, ease: "power2.inOut" });
            setTimeout(createGrandText, 4500);
        }

        function createGrandText() {
            const createLine = (text, y, size, color) => {
                const geo = new TextGeometry(text, { font: font, size: size, height: 1, bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.2 });
                geo.center();
                const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5, transparent: true, opacity: 0 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(0, y, 20);
                scene.add(mesh);
                gsap.to(mat, { opacity: 1, duration: 3 });
                gsap.to(mesh.position, { z: 40, duration: 6, repeat: -1, yoyo: true, ease: "sine.inOut" });
            };
            createLine("You are my whole world, Samya.", 15, 4.5, 0xffd700);
            setTimeout(() => {
                createLine("And I will love you in every universe.", -15, 3, 0xffdae0);
                document.getElementById('footer').style.opacity = '1';
                // Less frequent falling hearts (was 400ms, now 1200ms)
                setInterval(createFallingHeart, 1200); 
            }, 2000);
        }

        function createFallingHeart() {
            const heartShape = new THREE.Shape();
            heartShape.moveTo(0, 0);
            heartShape.bezierCurveTo(0, -0.3, -0.6, -1, -1.5, -1);
            heartShape.bezierCurveTo(-3, -1, -3, 1.1, -3, 1.1);
            heartShape.bezierCurveTo(-3, 2, -1.5, 3.2, 0, 4.5);
            heartShape.bezierCurveTo(1.5, 3.2, 3, 2, 3, 1.1);
            heartShape.bezierCurveTo(3, 1.1, 3, -1, 1.5, -1);
            heartShape.bezierCurveTo(0.6, -1, 0, -0.3, 0, 0);
            const geo = new THREE.ShapeGeometry(heartShape);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffb7c5, transparent: true, opacity: 0.4 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set((Math.random() - 0.5) * 200, 100, (Math.random() - 0.5) * 50);
            mesh.scale.set(0.5, 0.5, 0.5);
            scene.add(mesh);
            gsap.to(mesh.position, { y: -100, x: mesh.position.x + (Math.random() - 0.5) * 50, duration: 10 + Math.random() * 5, ease: "none", onComplete: () => scene.remove(mesh) });
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            if (currentPhase === 'galaxy') {
                galaxyItems.forEach(item => {
                    const data = item.userData;
                    item.position.applyAxisAngle(data.axis, data.orbitSpeed);
                    item.position.y += Math.sin(time + data.floatOffset) * data.floatSpeed;
                    item.rotation.x += 0.01; item.rotation.y += 0.01;
                });
                camera.position.x += (mouse.x * 10 - camera.position.x) * 0.05;
                camera.position.y += (-mouse.y * 10 - camera.position.y) * 0.05;
                camera.lookAt(0, 0, 0);
            }

            if (currentPhase === 'heart') {
                galaxyItems.forEach((item, i) => {
                    item.rotation.y = Math.sin(time + i) * 0.2;
                    item.position.z += Math.sin(time * 0.5 + i) * 0.02;
                });
                camera.position.x = Math.sin(time * 0.2) * 20;
                camera.lookAt(0, 0, 0);
            }

            // Solar System movement
            planets.forEach(p => {
                p.userData.angle += p.userData.orbitSpeed;
                p.position.x = Math.cos(p.userData.angle) * p.userData.orbitDistance;
                p.position.z = Math.sin(p.userData.angle) * p.userData.orbitDistance;
            });

            if (starField) starField.rotation.y += 0.0003;
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
